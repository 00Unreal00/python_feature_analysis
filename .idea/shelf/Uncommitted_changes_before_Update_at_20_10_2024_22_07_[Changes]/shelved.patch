Index: ее.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ее.py b/ее.py
new file mode 100644
--- /dev/null	(date 1729433694416)
+++ b/ее.py	(date 1729433694416)
@@ -0,0 +1,13 @@
+import numpy as np
+
+# Создаем случайный массив размером 15 на 7
+array = np.random.randint(0, 10, size=(3, 2))
+
+# Выводим массив
+print("Массив:\n", array)
+
+# Считаем сумму по столбцам (axis=0)
+column_sums = np.sum(array, axis=0)
+
+# Выводим суммы
+print("Суммы по столбцам:", column_sums)
Index: part3.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/part3.py b/part3.py
--- a/part3.py	(revision 504b63024f94bff70e87466bf65aee18e4d7af77)
+++ b/part3.py	(date 1729446214598)
@@ -1,0 +1,42 @@
+import numpy as np
+
+
+data = {'A': [], 'B': [], 'C': []}
+with open('artem.csv') as f:
+    keys = list(data.keys())
+    change_pos = 0
+    count = 0
+    for _ in range(1, 16):
+        line = list(map(int, f.readline().split()))
+        if line[0] > count:
+            count = line[0]
+            data.get(keys[change_pos]).append(line[1:])
+        else:
+            data[keys[change_pos]] = np.array(data.get(keys[change_pos]))
+            count = 0
+            change_pos += 1
+            data.get(keys[change_pos]).append(line[1:])
+    for i in keys:
+        data[i] = np.array(data.get(i))
+def fischer_one_class(one_class):
+    # axis=0 это столбцы axis=1 строки sum сумма
+    mean = np.mean(one_class, axis=0) # среднее значение по столбцам
+    std = np.std(one_class, axis=0) # среднеквадратическое отклонение по столбцам оказывается это СТАНДАРТНОЕ отклонение
+    ix = mean**2/std**2 # информативность
+    indexix = np.argsort(ix)# сортирует массив и выдаёт список индексов в каком порядке отсортировалось
+    #вар1
+    # return int(indexix[0]), float(ix[indexix[0]]), int(indexix[1]), float(ix[indexix[1]]) кортеж получается
+    #вар2
+    # min1 = ix[indexix[0]]
+    # min2 = ix[indexix[1]]
+    # i1 = indexix[0]
+    # i2 = indexix[1]
+    # return min1, min2, i1, i2
+    #вар3
+    return [indexix[0]+1, ix[indexix[0]], indexix[1]+1, ix[indexix[1]]]
+
+
+u = fischer_one_class(data.get("A"))
+print(f"Первый самый малый признак: {u[0]}, второй малый признак: {u[2]}")
+
+
